= OSGi Notes
From OSGi in Action - 2011
:toc:

== Why use OSGi?

It is used to address the lack of modularity in the Java platform.

Referred to as _SOA in a VM_.

=== What is modularity?
Code is separated into logical parts that have their own roles.

=== Java's limitations
==== Access Modifier
Java's access modifiers are good for low-level object-oriented aspects but does
not cater for modules.

Java uses a package to partition code, however for a code to be visible from one
package to another, it has to be defined as _public_. This makes those packages
also available to _everyone_. This will expose implementation details, and make
future refactorings harder as users may tend to rely on nonpublic API.

You could fix it by putting unrelated classes together in the same package, but
you'll break the logical structure of your application.

==== Classpath
The Java classpath does not pay any attention to code versions - it uses the
first version it finds.

Classpath hell:: More than one Jar file provides a given set of classes

You might suffer frm `NoSuchMethodError` when a class from one Jar file uses a
class with a different version from what it was expecting.

In large application, it isn't uncommon to have dependencies on different
versions of the same component.

==== Deployment and Management
There is no easy way to evolve your application and its components after
deployment. (e.g dynamic plugin mechanism)

=== Overview of OSGi
* OSGi framework
* OSGi standard services

The framework is the runtime and implements the OSGI functionality.
The sservices define APIs for common tasks, such as logging and preferences.

=== OSGi layers
* Module layer
+
Concerned with packaging
* Lifecycle layer
+
Providing module management and access to the OSGi framewrk
* Service layer
+
Interaction and communication among modules


==== Module layers
Bundle:: Jar file with extra metadata. A bundle is also the OSGi module concept.

A bundle will contains all the typical stuff you will expect in a jar file
(class files and resources). Bundles are logical modules that combine to form a
given application. Bundles can declare which packages should be visible to other
bundles. So we don't suffer anymore from the problem of access modifiers and
different packages.

You can also declare which external packages the bundles depend on.

Advantage of doing this is that the OSGi framework can then manage the versions
by themselves; we avoid the classpath problem.

==== Lifecycle layer
This layer defines how the bundles are managed in the framework.

Bundle lifecycle::
* install
* update
* start
* stop
* uninstall

Lifecycle layer also defines how bundles gain access to their execution context.
The context allows the bundles to talk to the OSGi framework and use the
facilities it provides during execution.

==== Service layer
Service providers publish their services into a service registry, while service
clients search the registry to find available services to use.

The service layer promotes an interface-bsed development approach.

=== Putting all together
Metadata to add to `META-INF/MANIFEST.MF`:

----
Bundle-ManifestVersion: 2                       <1>
Bundle-Name: Greeting API                       <2>
Bundle-SymbolicName: org.foo.hello              <3>
Bundle-Version: 1.0                             <4>
Export-Package: org.foo.hello;version="1.0"     <5>
----
<1> OSGi metadata syntax version
<2> Human-readable Name
<3> Symbolic Name
<4> versions
<5> Important part: extends the functionality of a typical jar file so that you
can declare which packages in the jar are visible to its users. Only contents in
`org.foo.hello` are externally visible.

For other modules to define a dependency on another module:

----
[...]
Import-Package: org.foo.hello;version="[1.0, 2.0)]"
----


==== Lifecycle example

[source,java]
----
public class Activator implements BundleActivator {
    public void start(BundleContext ctx) {
        // initialize
    }
    public void stop(BundleContext ctx) {
        // stop
    }
}
----

Since the framework uses the same activator instance while the bundle is active,
we can share variables between `start` and `stop`.

`BundleContext` allows us to get access to the OSGi framework.

To tell the framework about the bundle activator, you have to add this to your
manifest:

----
Bundle-Activator: org.foo.hello.Activator
Import-Package: org.osgi.framework              <1>
----
<1> We need this since the bundle activator has a dependency on it.


==== Service layer example
